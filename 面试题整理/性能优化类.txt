如何改善项目的首屏加载性能?
首屏加载性能受这些影响:
1.文件请求数量
2.单个文件大小
3.图片大小
4.图片数量

解决单个文件请求大小的话，首先要想办法把node_modules中的模块和我们项目的业务代码分开
那么总的来说有两种办法可以这么做，一种是用DLLplugin ,这个稍微麻烦点，要单独打包node_modues
中的文件，然后再在主配置文件中添加外部依赖。
还有一个更简单的方法，就是用splitChunks将node_modues目录下所有文件单独打包成一个chunk
将node_modues打包成单个chunk也有个好处，就是可以在浏览器端和cdn端上做缓存，用户请求了一次以后就
不需要反复下载一个一样的,并且不频繁更新的chunk,还可以实现增量更新的效果。

第二，需要将一些首屏外的模块做成异步载入的，例如菜单中的其它模块，或者首屏之下的一些模块，
可以用懒加载来解决。然后设置splitChunks自动将异步模块生成单独的chunk. 这样一来首屏单个文件的体积
就会大大缩小。

然后将treeshakeing的功能打开把一些引入了但是没用的模块或者变量扔掉。

如果首屏幕请求文件多且小，那么可以将一些多余的异步请求换成同步的，让它们和主chunk打包在一起。
然后在后处理那边把minimizer打开，用terserPlugin将代码压缩一下。
再开个gzip压缩，webpack直接生成gzip文件
在部署的时候再直接让web服务器将webpack的gzip文件发出去，这样代码这边会压到很小。

图片太大的话可以用tinyPng插件进行图片压缩。
图片多的话可以用base64将一些小图标小图片打包到代码里去，用fileLoader就能做。
或者还有一种更传统的方式，就是用雪碧图，这个我已经很少用了，所以没有研究过在webpack里用它的方法.



---------------------------------------------------------------------------------------------------------
如何改善webpack的打包性能？
主要优化的方面一个是开发环境，第二个是生产环境。
开发环境可以把大多数用不到的后处理功能都关了，比如代码压缩，gzip压缩
重复模块打包检测，检测是否有空分支，splitChunk功能，模块合并功能，treeshakeing，代码压缩混淆等。
开发环境下可以开启懒编译功能加快启动速度。

生产环境的速度主要需要开启持续化缓存，使用多线程loader处理。
多线程loader处理的话可以用threadLoader  或者HappyPack
然后TerserPlugin的话根据cpu的情况把线程开多一点

一般splitChunk开了以后加持续化缓存可以节省很多编译时间.


---------------------------------------------------------------------------------------------------------
如何改善页面的运行效率？
一般运行效率不佳往往是一些过于复杂的动画引起的，一些容易频繁造成回流的操作要检查一下，例如频繁去获取offset,scrollTop等
对于频繁获取的问题可以检查看看是不是在循环里操作了这些东西，可以用debunce或者thrttle来解决。一些动画能用transform+translate
做的就不要用js做，尽量不要去更改盒子模型的属性，且可以使用will-change属性强制一些节点在浏览器中分层并告知浏览器将会做一些什么
操作，让浏览器去对这些即将到来的操作做预渲染。如果这些都不成，说明页面上的动画太复杂，考虑用canvas或者直接用pixi来做。

---------------------------------------------------------------------------------------------------------
缓存分为哪些类型？
Http缓存
Memory cache
Service Worker Cache
Push Cache

http缓存的话主要分为：
1.强缓存
2.协商缓存 304缓存

主要是依靠响应header中的Cache-Control来进行控制的，
主要可用字段有 maxAge  s-maxAge
maxAge控制浏览器端的缓存时间（秒）
s-maxAge控制cdn端的缓存时间(秒)
存设置项：
 - private：仅浏览器可以缓存（默认值）；
 - public：浏览器和代理服务器都可以缓存；
 - max-age=xxx：浏览器的过期时间单 位秒
 - no-cache：不进行强缓存；
 - no-store：不强缓存，也不协商缓存）
 - s-maxage:设置cdn的缓存过期时间 位秒


MemoryCache
MemoryCache,是指存在内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的缓存了。

生命周期:Tab关了就没了。

那么哪些文件会被放入内存呢？

资源存不存内存，浏览器秉承的是“节约原则”。我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，
这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相
比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。

还有图片对象请求的图片也会被放入内存。












































































