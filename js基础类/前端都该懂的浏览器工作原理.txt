浏览器工作原理
https://zhuanlan.zhihu.com/p/140700610
https://juejin.cn/post/6844904146982666254

浏览器内有哪些进程，这些进程都有些什么作用
浏览器地址输入 URL 后，内部的进程、线程都做了哪些事
我们与浏览器交互时，内部进程是怎么处理这些交互事件的

------------------------------------------------------------------------

浏览器架构:

在理解浏览器架构之前，先理解两个概念，进程和线程

浏览器的多进程架构:

在 chrome 中，主要的进程有 4 个:

- 浏览器进程:负责浏览器除了页面渲染区域以外的其它功能，例如地址栏，前进后退，设置，收藏等
- 渲染进程：负责一个 tab 页面没的显示相关工作，也称渲染引擎。
- 插件进程：负责控制网页使用到的插件
- GPU 进程:负责处理整个应用程序的 GPU 任务

第一步：处理输入

第二步：开始导航

第三步：读取响应

第四步：查找渲染进程

第五步：提交导航

第六步：初始化加载完成

网页渲染原理
构建 DOM
资源子加载
JavaScript 的下载与执行
样式计算 - Style calculation
布局 - Layout
绘制 - Paint
合成 - Compositing
浏览器对事件的处理
渲染进程中合成器线程接收事件
查找事件的目标对象（event target）
浏览器对事件的优化

---------------------------------------------------------------

Http 请求具体流程大概分为八个阶段
 - 构建请求
 - 查找缓存
 - 预备IP和端口
 - 等候TCP行列
 - 建立TCP链接
 - 建立HTTP请求
 - 服务器处理请求
 - 服务器返回请求
 - 断开链接

---------------------------------------------------------------
渲染线程都有哪些:
- Gui线程，浏览器拿到请求资源后，有一部操作就是，根据html和css文件分别生成dom树和样式树，
    然后生成渲染树和布局树，这部分的工作就是gui线程完成的。  

- js线程：又称js主线程，就是用来执行js代码的。

- 合成器线程：该线程获得布局树以后，通过栅格化获取一帧数据，最终交由gpu处理。

重点：gui线程和js线程是互斥的，当js在更新dom树的时候，因为这么操作可能导致重排和重绘，
因此，在 js线程运行的时候，GUI线程会挂起。

- 定时器线程: 如果当js主线程执行代码时，遇到setTimeout和setInterval这两种定时器时，js线程
会把定时器函数扔给定时器线程处理，自己继续往下执行。定时器线程等待设定时间后，将定时的回调函数
交给事件触发线程，由事件触发线程负责将回调函数塞入任务队列。从这个过程能够得到前面疑问的答案。
单线程的异步请求，就是通过渲染进程的多线程架构实现的，定时器函数并不执行具体的代码，只是用来等待
定时器时间到达。当我们定义了多个定时器，谁先结束等待，谁就先进去事件触发线程里。

- 事件触发线程：也不执行任何代码，主要任务是将函数加入主线程的队列。

- 异步HTTP请求线程：负责处理异步的ajax请求,当请求完成之后，他也会通知事件触发线程，然后事件触发
线程将这个事件放入事件队列，给主线程执行。

- 网络进程：负责发起和接受网络请求

- GPU进程：负责整个页面的渲染。

- 插件进程: 用来管理外部插件（并不是浏览器插件）


-------------------------------------------------------------------
简略版的渲染机制:

简略版的渲染机制一般分为以下几个进程:

1.处理HTML并构建DOM树
2.处理CSS并构建CSSOM树
3.将DOM和CSSOM兼并成一个渲染树
4.依据渲染树来布局，核算每个节点的方位。
5.调用GPU制作，组成图层，显示在屏幕上。

在构建cssom树时，会阻塞渲染，直到cssom树构建完成。并构建cssom树时一个十分耗费资源的进程，所以应该尽
量保证层级扁平，削减过度层叠，越是详细的css查询语句，运行速度越是慢

当HTML解析到script标签的时候，会暂停dom树的构建，当script运行完成之后才会继续接下来的DOM树的构建，
也就是说如果你想让用户能够流畅地看到你的首屏，那就不能在html页面的一开始就放置阻塞式的script标签
应该把标签尽量往后移动。并且css也会影响js的运行，只有当解析完样式表之后才会运行js,所以这种情况下css
的解析也会暂停dom树的构建。

 - Load: Load的触发代表页面中的DOM CSS JS 图片已经完全加载结束。
 - DOMContentLoaded事件触发代表初始的Html被彻底加载和解析，不需要等待css,Html,js以及图片的加载
 - 绑定readystatechange也可以监听页面的载入情况，jquery就是这么实现页面是否载入完成监听的
    if (this.readyState == "complete")  才能是载入完成

------------------------------------------------------------------
层
一般来说，不同的层之间的渲染互不影响，所以建议一些频繁渲染的层单独做一个新的层改善运行效率，但也不能有
太多那样的层，会引起反效果。

经过以下几个常用属性可以构建层:
3D 改换：translate3d、translateZ
will-change
video、iframe 标签
经过动画完结的 opacity 动画转化
position: fixed

-------------------------------------------------------------------
重绘 和 回流
重绘和回流是当前前端排版中两个重要的概念。

 - 重绘是指仅仅改变不会与相邻元素间产生互动的属性，例如color,font-color,border-color,opacity等
 - 回流是指当一个元素改变了大小，或者float或者边距，那么他可能就会影响他相邻的元素，那么就会调至页面的
 重排，也就是回流。
    当然，重排（回流）的时候也会相应地触发重绘

所以以下的动作，会导致浏览器进行回流操作:
 - 改动window的大小
 - 改动字体
 - 增加或者删除样式
 - 文字的改动
 - 定位，或者float
 - 盒子模型的属性变动

其实很多人可能不太清楚的是，重绘和回流与EVENTLOOP有关

1.当EventLoop执行完微任务之后，会判断document树是否需要更新，由于浏览器是60hz的刷新率，每16毫秒就会更新一次
2.然后判断是否有resize或者scroll,有的话才会去执行相应的代码。
3.判断是否触发了mediaQuery
4.更新动画。
5.判断是否有全屏的操作
6.执行requestAnimationFrame回调
7.执行IntersectionObserver回调们该方法用于判别元素是否可见
8.更新画面
9.以上便是在一帧中会做的事情，如果在这帧中没有别的事情可做，就会去执行requestIdleCallback 回调。

--------------------------------------------------------------------
尽量增加重绘和回流的性能:
1.使用translate代替top,left,width,height
2.使用visibility代替display：none(某些时候可以用)
3.不要吧dom的属性值放在循环里获取
4.不要使用table布局，因为很小的改动就会使table从头到尾重新回流绘制一遍(看情况。有时候非要用table也没办法)
5.js动画尽量使用requestAnimationFrame来做
6.将频繁运动的动画变为图层，图层能够阻挠该节点因为回流而音响其它元素。

--------------------------------------------------------------------
详细版的渲染机制:
较为专业的术语总结为以下阶段:
1.构建DOM树
2.构建css树
3.构建布局树
4.分层
5.图层绘制
8.光栅化
9.显示

从浏览器拿到字节数据，渲染模块们一步步地进行渲染到你的屏幕上，这个过程，我们叫渲染流水线。

------------------
1.构建DOM树

字节数据
↓
html的文本字符
↓
令牌对象
↓
转化成节点对象
↓
组织成dom数

--------------------
2.样式计算
这个子阶段首要有三个进程
 - 格式化样式表
 - 标准化样式表
 - 计算每个dom节点的详细样式

字节数据
↓
css的文本字符
↓
令牌对象
↓
转化成节点对象
↓
组织成css树

-------------------------------
3.生成布局树
浏览器会根据dom树和css树来生成一个布局树，或者叫渲染树

建立渲染树:
1.在dom树上不可见的元素，例如display:none head meta 等等的元素在dom树里会被标记成不需要渲染的
渲染树也会跳过它们的渲染。于是在构建渲染树的时候，浏览器会跳过这些元素

为了构建布局树，浏览器布局体系大体完成了下面这些事情：

 - 遍历DOM可见节点，并将这些节点加入到布局树种去。

用人话就是，使用DOM树和css树，合并起来生成一颗新的树，并在构建过程中过滤掉不可见的元素，例如head script
之类的或者display:none 这样的

【布局计算】
就是遍历刚刚生成好的布局树，计算每个元素的绝对坐标，大小，颜色等等

-------------------------------
4.分层（生成图层树）Composite

你最终看到的界面，都是由这些图层叠加构成的
浏览器的页面实践上被分成了许多图层，这些图层叠加后组成了最终的页面。

一般情况下并不是布局树的每个节点都是一个层，加入一个节点没有对应的层，那么它就属于父节点的图层。

那什么情况下渲染树会给特定节点建立新的图层呢?
 - 一种是显式的
 - 一种是隐式的

1.显式组成

    一、 具有层叠上下文的节点。

        层叠上下文也基本上是有一些特定的CSS特点创立的，一般有以下状况:

        1.HTML根元素本身就具有层叠上下文。(z-index)
        2.一般元素设置position不为static并且设置了z-index特点，会产生层叠上下文。
        3.元素的 css opacity 值不是 1
        4.元素的 css transform 值不是 none
        5.元素的 css filter 值不是 none
        6.元素的 css isolation 值是isolate
        7.css will-change指定的特点值为上面恣意一个。(will-change的作用后边会详细介绍)

    二，被迫出现了滚动条的地方也会被图层树定义为一个层


2.隐式组成
    如果一个元素覆盖在一个拥有独立图层的元素上，并且这个元素的z-index值更大，那这个元素也会被提升到单独的
    图层中。

    层爆炸和层压缩
    像上面那种隐式创建图层的情况，如果不加注意，极端场景下可能会创建大量独立图层，也就是层爆炸，会占用GPU和
    大量的内存资源，严重损耗页面性能。浏览器也有相应的对策，浏览器的层压缩机制，会将隐式创建的多个图层压缩到
    一个图层中。

-------------------------------------
5.图层绘制
得到图层树之后，会组织称一个图层绘制列表。

-------------------------------------
6.栅格化
将图层绘制列表里的内容提交给GPU进行栅格化渲染

-------------------------------------
7.显示

一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的指令——“DrawQuard”，然后将该指令提交给浏览器进程。
浏览器进程中的viz组件接收到指令后，将页面内容绘制到内存中，最后再将内存中的页面显示在屏幕上。
每个显示器都有固定的刷新频率，通常是60Hz，即每秒更新60张图片，更新的图片都来自于显卡的前缓冲区。显示器每
秒固定读取60次前缓冲区中的图像来显示。显卡中的GPU合成新的图像，保存到后缓冲区。然后系统将显卡的前后缓冲区
互换，来让显示器读取最新的图像。通常，显卡的更新频率和显示器的刷新频率是一致的，但有时在一些复杂场景中，显
卡处理一张图片的速度变慢，就造成了视觉上的卡顿。
页面上的动画效果例如滚动，渲染引擎通过渲染流水线生成新的图片发送到显卡的后缓冲区，要想实现流畅的动画效果，
渲染引擎需要每秒更新60张图片到显卡的后缓冲区。每一副图片称为一帧，每秒更新了多少帧称为帧率，如果滚动过程中1
秒更新了60帧，帧率就是60Hz（或60FPS）。如果一次动画中，渲染引擎生成某些帧的时间过久，用户就会感觉到卡顿。
渲染流程结束后，渲染进程会发送一个消息给浏览器进程，浏览器进程停止标签图标上的加载动画。

-------------------------------------
总结

1.渲染进程将HTML解析为为DOM树结构。
2.渲染引擎将CSS样式表解析为CSSOM，并计算出DOM节点的样式。
3.创建布局树，并计算元素的布局信息。
4.对布局树进行分层，并生成分层树。
5.为每个图层生成绘制列表，并将其提交到合成线程。
6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7.合成线程发送绘制图块命令DrawQuad给浏览器进程。
8.浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。



-----------------------------------
重排
如果修改了元素的几何位置属性，如改变宽高，会引发重新布局及之后一系列流程，这个过程叫做重排。
调用以下DOM API，为了保证结果的准确性，浏览器会触发重排以获取最新的信息：

offsetTop、offsetLeft、offsetWidth、offsetHeight(元素包含边框的宽/高)
scrollTop、scrollLeft、scrollWidth、scrollHeight(元素包含内边距的包含不可见的滚动内容的宽/高)
clientTop、clientLeft、clientWidth、clientHeight(元素包含内边距的宽/高)
window.getComputedStyle(elem)、IE里的currentStyle
getBoundingClientRect()



-----------------------------------
重绘
不改变几何位置信息，只改变元素的如背景颜色等信息，引发重新绘制及之后一系列流程，这个过程叫做重绘。



-----------------------------------
合成
如果既不要布局也不要绘制的属性，渲染引擎会跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。例如使用CSS的transform来实现动画效果，可以避开重排和重绘阶段，在非主线程上执行合成动画的操作，无需占用主线程的资源，大大提高了效率。
因此在执行效率方面：合成 > 重绘 > 重排。在性能优化方面可以依据这个原则来调整方案。















